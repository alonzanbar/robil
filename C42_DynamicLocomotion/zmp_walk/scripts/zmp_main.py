#!/usr/bin/env python

###################################################################################
####	                                                                           ##
####	zmp_main.py (based on zmp_main(old).py)                                    ##
####	Created - Israel 25/12/2012 	                                             ##
####  last updated - version 2.0, Yuval 04/2/2013                                ##
####                                                                             ##
####    run this script to initiate zmp node           	                         ##
####    to start walking: rostopic pub /zmp_walk_command std_msgs/Int32 1        ##
####    to stop walking:  rostopic pub /zmp_walk_command std_msgs/Int32 0	       ##
####                                         	                                   ##
####    this node runs with parameters generated by matlab and are stored	       ##
####    in the file '/src/parameters'.	                                         ##
####    the walking patern in governed by the parameters: 			                 ##
####    step_length,step_width and step_time		                                 ##
####	                                                                  	       ##
###################################################################################			

import roslib; roslib.load_manifest('zmp_walk') #roslib.load_manifest('leg_ik')
import rospy, sys #,os.path
from pylab import *
# from numpy import * # no need after line above
from zmp_walk.msg import traj
from std_msgs.msg import Int32
from preview_controller import ZMP_Preview_Controller
from zmp_profiles import *
from preview_buffer import ZMP_Preview_Buffer


rospy.init_node('zmp_movement_plan')  #('ZMP_node')
rospy.loginfo("started ZMP node")

class namespace: pass
ns = namespace()
ns.walk = 0

def listn_to_command(zmp_walk_command): 
    ns.walk = zmp_walk_command.data
    rospy.loginfo("recieved zmp_walk_command: walk = %i" % (ns.walk) )
    rospy.loginfo("time:")
    rospy.loginfo(rospy.get_time())

pub_zmp = rospy.Publisher('zmp_out', traj)
sub_command = rospy.Subscriber('zmp_walk_command' , Int32 , listn_to_command)

interval = rospy.Rate(100)
out = traj()

zc = 0#0.8455 # [m] COM height

dt = 0.01  # [sec] # sample time (was named time_step)

# Walking Parameters 

step_length = 0.0001 #0.01  # [m]
step_width  = 0.175  # 0.178  # [m]
step_time   = 8 #1   # [sec]
bend_knees  = 0.04  # [m]    
step_height = 0.0001 #0.03 #0.05  # [m] 
# half_trans_ratio = 0.5 # units fraction: 0-0.5
trans_ratio_of_step = 0.8 # units fraction: 0-1.0 ; fraction of step time to be used for transition. 1.0 = all of step time is transition 
trans_slope_steepens_factor = 2 # 1 transition Sigmoid slope (a)

# Preview Controllers:
Sagital_x_Preview_Controller = ZMP_Preview_Controller('X_sagital','sagital_x',0.0) # name, parameters_folder_name, initial position of COM 
Lateral_y_Preview_Controller = ZMP_Preview_Controller('Y_lateral','lateral_y',step_width/2) # name, parameters_folder_name, initial position of COM

NL = Lateral_y_Preview_Controller.getBufferSize() 

# Preview Buffers:
Preview_Sagital_x = ZMP_Preview_Buffer('Sagital X', NL, 4*step_time/dt, 0 ) #name, preview_sample_size, max_step_samples, precede_time_samples
Preview_Lateral_y = ZMP_Preview_Buffer('Lateral Y', NL, 4*step_time/dt, 0 ) #name, preview_sample_size, max_step_samples, precede_time_samples

# init preview:
p_ref_x = zeros(NL)
p_ref_y = zeros(NL)

# t1 = arange(0 , step_time-2*half_trans_ratio*step_time+dt , dt)    # arange(0 , step_time-2*0.1*step_time+dt , dt)
# t0x = arange(0 , 2*step_time-half_trans_ratio*step_time+dt   , dt) # arange(0 , 2*step_time-0.1*step_time+dt   , dt)
# t0y = arange(0 , step_time-half_trans_ratio*step_time+dt   , dt)   # arange(0 , step_time-0.1*step_time+dt   , dt)

# p_ref1x = step_length*ones(( len(t1) ))
# p_ref1y = step_width*ones(( len(t1) ))
# p_ref0 = zeros(( len(t1)-1 ))
# p_ref0_0x = zeros(( len(t0x)-1 ))
# p_ref0_0y = (step_width/2)*ones(( len(t0y)-1 ))


out.COMx = 0         
out.COMy = 0
out.COMz = zc -bend_knees       
out.Swing_x = 0       
out.Swing_y = 0
out.Swing_z = bend_knees

# Main Loop

go = 0
Leg = 1
left = 1 # when Leg=1 right leg is swing leg
ka=0
while not rospy.is_shutdown():

  if(ka>6):
   out.COMx =  out.COMx #0.04*sin( 6.28*0.0008*(ka-6) )#out.COMx #  0.02*cos( 6.28*0.0008*(ka-6) )#out.COMx   #
   out.COMy =  out.COMy    #0.04*sin( 6.28*0.0008*(ka-6) )  #
   out.COMz = out.COMz  
   out.Swing_x = out.Swing_x     
   out.Swing_y = out.Swing_y
   out.Swing_z = out.Swing_z  
   out.leg = Leg 
  # rospy.loginfo(out.COMy)
  ka = ka +1
  
  pub_zmp.publish(out) 
  interval.sleep()

  if ns.walk == 1:
      
      rospy.loginfo("started walking")
      rospy.loginfo("time:")
      rospy.loginfo(rospy.get_time())
      #D     = 0.0

      k     = 1
      samples_in_step = ceil (step_time / dt)

      step_length_z = step_length;
      step_time_z = step_time;
      pre_step = 1
      first_step = 0
      full_step = 0
      #last_step_mes = 0
      go = 1
      steps_count = 0 #-1
      last_step = 0
      step_done = 0
      swing_x_v = []
      swing_z_v = []
      # p_ref_x = r_[ p_ref0_0x , sigmoid_x , p_ref1x ]
      # p_ref_y = r_[ p_ref0_0y , sigmoid_y/2+step_width/2 , p_ref1y ]
      swing_z_t_more_double_support = 0
      swing_x_t_more_double_support = 0

      distance_x_ref = 0 # the accumelated ZMP ref distance past, is updated at the end of each step 
                         # and used as initial starting point for the next step
      step_phase = 1 # Double-Support left leg in front

      # create ZMP_ref profiles: 
      # 1) to start walking (pre_step + first_step)
      p_ref_x_start = Start_sagital_x(0, step_length, trans_ratio_of_step, trans_slope_steepens_factor, step_time, dt)
      p_ref_y_start = Start_lateral_y_weight_to_left_foot(0, step_width, trans_ratio_of_step, trans_slope_steepens_factor, step_time, dt)
      # 2) preceeding steps (full_step)
      p_ref_x_forward_step = Step_forward_x(0, step_length, trans_ratio_of_step, trans_slope_steepens_factor, step_time, dt)
      p_ref_y_step_right = Step_onto_right_foot(0, step_width, trans_ratio_of_step, trans_slope_steepens_factor, step_time, dt)
      p_ref_y_step_left = Step_onto_left_foot(0, step_width, trans_ratio_of_step, trans_slope_steepens_factor, step_time, dt)

      # Load the starting step to preview buffer:
      Preview_Sagital_x.load_NewStep( p_ref_x_start, p_ref_x_forward_step )
      Preview_Lateral_y.load_NewStep( p_ref_y_start, r_[ p_ref_y_step_right, p_ref_y_step_left ] ) 

  while go == 1:

  #######################################################
  #                                                     #
  # sagital control   (x)                               #
  #                                                     #
  #######################################################

      p_ref_x = Preview_Sagital_x.update_Preview()
      [COMx, COMx_dot] = Sagital_x_Preview_Controller.getCOM_ref( p_ref_x )


  #######################################################
  #                                                     #
  # lateral control  (y)                                #
  #                                                     #
  #######################################################

      p_ref_y = Preview_Lateral_y.update_Preview()
      [COMy, COMy_dot] = Lateral_y_Preview_Controller.getCOM_ref( p_ref_y )

  #######################################################
  #                                                     #
  # foot trajectory                                     #
  #                                                     #
  #######################################################

      k_total = step_time*100
      k_start_swing =  round(k_total/3)
      k_stop_swing =   round(2*k_total/3)

      if pre_step:
         swing_pre_step = abs(sin(pi/(step_time_z)*(k-1)*(dt)))
         swing_x_t = 0 
         swing_y = 0
         swing_z_t = 0 

      if full_step:  
         #swing_x_t = -step_length_z + 2*(k-1)*dt*step_length_z/step_time_z
         swing_y = 0
         swing_z_t = 0.05*abs(sin(pi/step_time_z*(k-1)*dt))


         if(k>k_start_swing  and k<k_stop_swing ):
              swing_x_t_more_double_support = -step_length_z +2*(k-k_start_swing)*step_length/(k_stop_swing - k_start_swing)
              swing_z_t_more_double_support = step_height*abs( (sin(pi/(k_stop_swing -k_start_swing)*(k - k_start_swing)))**2 ) #step_height*abs(sin(pi/(k_stop_swing -k_start_swing)*(k - k_start_swing)))  
         elif k<k_start_swing:
              swing_z_t_more_double_support = 0
              swing_x_t_more_double_support = -step_length
         elif k>k_stop_swing:
              swing_z_t_more_double_support = 0
              swing_x_t_more_double_support = step_length



      if first_step:  

         #swing_x_t = (k-1)*dt*step_length/step_time
         #rospy.loginfo(swing_x_t)
         swing_y = 0#-0.02*(k-1)*dt/step_time 
         swing_z_t = 0.06*abs(sin(pi/step_time*(k-1)*dt))
 
         if(k>k_start_swing  and k<k_stop_swing ):
              swing_x_t_more_double_support = (k-k_start_swing)*step_length/(k_stop_swing - k_start_swing)
              swing_z_t_more_double_support = step_height*abs( (sin(pi/(k_stop_swing -k_start_swing)*(k - k_start_swing)))**2 )  
 
         elif k<k_start_swing:
              swing_z_t_more_double_support = 0
              swing_x_t_more_double_support = 0 #-step_length
         elif k>k_stop_swing:
              swing_z_t_more_double_support = 0
              swing_x_t_more_double_support = step_length
      if last_step:  
         swing_x_t = -step_length_z + (k-1)*dt*step_length_z/step_time_z
         swing_y = 0
         swing_z_t = 0.05*abs(sin(pi/step_time_z*(k-1)*dt))

      
      swing_x_v = r_[ swing_x_v , swing_x_t_more_double_support ]
      swing_z_v = r_[ swing_z_v , swing_z_t_more_double_support ]
  #######################################################
  #                                                     #
  # publish zmp                                         #
  #                                                     #
  #######################################################

      out.COMx = COMx
      out.COMy = COMy - step_width/2
      out.COMz = zc -bend_knees
      out.Swing_x = swing_x_t_more_double_support
      out.Swing_y = swing_y
      out.Swing_z = swing_z_t_more_double_support + bend_knees
      out.leg = Leg                                                           #1           for debuging

      pub_zmp.publish(out) 
      ##
     # rospy.loginfo('COMy=%f' %out.COMy )
  #######################################################
  #                                                     #
  # command control                                     #
  #                                                     #
  ####################################################### 
      
      # pre_step:  

          
      if pre_step:
          if (samples_in_step <= k): # swing_pre_step < 0.00001 and pre_step and k>1:
            # completed pre_step
            rospy.loginfo("done pre step")
            rospy.loginfo("time:")
            rospy.loginfo(rospy.get_time())

            # start first step:
            pre_step = 0
            first_step = 1
            step_phase = 1 # Double-Support left leg in front
            k = 1
            
      elif first_step:
            if (samples_in_step <= k):   #swing_z_t < 0.00001 and k>1 and not pre_step:
              # completed start steps (pre_step + first_step)
              step_done = 1
              steps_count = steps_count + 1
              rospy.loginfo("done first step, number = %d" % (steps_count) )
              rospy.loginfo("time:")
              rospy.loginfo(rospy.get_time())
          
              first_step = 0
              k = 1
              distance_x_ref = p_ref_x[0]
              step_phase = 3 # Double-Support right leg in front

              if ns.walk:
                # make a full step:
                full_step = 1
                # TODO: update ZMP_profiles with new parameters: step time,length...
                # Load new step to preview buffer:
                Preview_Sagital_x.load_NewStep( p_ref_x_forward_step + distance_x_ref, p_ref_x_forward_step )
                Preview_Lateral_y.load_NewStep( p_ref_y_step_right, r_[ p_ref_y_step_left, p_ref_y_step_right ] )
              else:
                # last step:
                last_step = 1
                # TODO: add stop ZMP_profiles


      else:
          if full_step:
              if (samples_in_step <= k):
                # completed a full step
                step_done = 1
                steps_count = steps_count + 1
                rospy.loginfo("done step number = %d" % (steps_count) )
                rospy.loginfo("time:")
                rospy.loginfo(rospy.get_time())

                k = 1
                distance_x_ref = p_ref_x[0]
                if step_phase >= 3:
                  step_phase = 1 # Double-Support left leg in front
                else:
                  step_phase = 3 # Double-Support right leg in front
                rospy.loginfo("step phase = %d" % (step_phase))

                if ns.walk:
                  # make a full step:
                  full_step = 1
                  # TODO: update ZMP_profiles with new parameters: step time,length...
                  # Load new step to preview buffer:
                  Preview_Sagital_x.load_NewStep( p_ref_x_forward_step + distance_x_ref, p_ref_x_forward_step )
                  if step_phase == 1:
                    Preview_Lateral_y.load_NewStep( p_ref_y_step_left, r_[ p_ref_y_step_right,p_ref_y_step_left ] )
                  else:
                    Preview_Lateral_y.load_NewStep( p_ref_y_step_right, r_[ p_ref_y_step_left, p_ref_y_step_right ] )
                
                else:
                  # last step:
                  last_step = 1

          elif last_step:
              if (samples_in_step <= k):
                # ?? TODO: allow another step cycle for stop step -> if (2*samples_in_step <= k):
                distance_x_ref = p_ref_x[0]
                go = 0
                rospy.loginfo("stoped walking")

          else:
             rospy.loginfo("Error: Problem step state not found. step phase = %d" % (step_phase))



          # if steps_count >= 0:
          #     Leg = int(Leg!=1)
          # rospy.loginfo("Right Leg = %d" % (Leg))
          #rospy.loginfo(Leg)
          # if steps_count > -1:
          #     plot(p_ref_x)
          #     plot(p_ref_y)
          #     plot(swing_x_v)
          #     plot(swing_z_v)
          #     # show()
          #     #rospy.loginfo("exited")
          #     # exit()                        # uncomment TO STOP AFTER ONE STEP
   
      # # full step:
      # if first_step and step_done and ns.walk:
      #    first_step = 0
      #    full_step = 1
      
      # # last step:   
      # if ns.walk == 0 and step_done and not last_step:
      #    last_step = 1
      #    first_step = 0
      #    full_step = 0
      #    #last_step_mes = p_ref_x[k] 
    
      # if p_ref_x[k] >= last_step_mes+step_length and last_step:
      #    go = 0
      #    rospy.loginfo("stoped walking")


      #rospy.loginfo(k)
      step_done = 0
      interval.sleep()
      k  = k + 1
      
  #end while go

#end while not rospy.is_shutdown()
