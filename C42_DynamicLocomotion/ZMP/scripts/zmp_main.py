#!/usr/bin/env python

###################################################################################
####	                                                                         ##
####	zmp control main                                                         ##
####	last updated - Israel 25/12/12	                                         ##
####                                                                             ##
####    run this script to initiate zmp node           	                         ##
####    to start walking: rostopic pub /zmp_walk_command std_msgs/Int32 1        ##
####    to stop walking:  rostopic pub /zmp_walk_command std_msgs/Int32 0	 ##
####                                         	                                 ##
####    this node runs with parameters generated by matlab and are stored	 ##
####    in the file '/src/parameters'.	                                         ##
####    the walking patern in governed by the parameters: 			 ##
####    step_length,step_width and step_time		                         ##
####	                                                                  	 ##
###################################################################################			

# Ros Parameters Initialization

import roslib; roslib.load_manifest('leg_ik')
from numpy import *
import rospy, sys,os.path
from pylab import *
from leg_ik.msg import *
from std_msgs.msg import Int32

rospy.init_node('ZMP_node')
rospy.loginfo("started ZMP_node")

class namespace: pass
ns = namespace()
ns.walk = 0

def listn_to_command(zmp_walk_command): 
    rospy.loginfo("recieved zmp_walk_command:")
    ns.walk = zmp_walk_command.data
    rospy.loginfo(ns.walk)
    rospy.loginfo("time:")
    rospy.loginfo(rospy.get_time())
pub_zmp = rospy.Publisher('zmp_out', traj)
sub_command = rospy.Subscriber('zmp_walk_command' , Int32 , listn_to_command)

interval = rospy.Rate(100)
out = traj()

# Control Parameters
[pathname, Script_File_Name] = os.path.split(sys.argv[0])
[Sub_pathname, Script_Folder] = os.path.split(pathname)

parameters_path = os.path.join(Sub_pathname, r"src/parameters/")


A = genfromtxt(parameters_path + 'A.txt')
B = genfromtxt(parameters_path + 'B.txt')
C = genfromtxt(parameters_path + 'C.txt')

Gi = genfromtxt(parameters_path + 'Gi.txt')
Gx = genfromtxt(parameters_path + 'Gx.txt')
Gd = genfromtxt(parameters_path + 'Gd.txt')
NL = genfromtxt(parameters_path + 'NL.txt')

zc = 0#0.8455 # [m]

time_step  =  0.01  # [sec] 

# Walking Parameters 

step_length = 0.0001 #0.01  # [m]
step_width  = 0.175  # 0.178  # [m]
step_time   = 1.5 #1   # [sec]
bend_knees  = 0.04  # [m]    
step_height = 0.0001 #0.05  # [m] 

# Sigmoid Plot


a =  1 #5 # 50  #100  # change slop of ZMP -> com
s =  arange(-3*step_time, 3*step_time+time_step , time_step) #arange(-1.5*step_time,1.5*step_time+time_step , time_step) # arange(-0.1*step_time,0.1*step_time+time_step , time_step) #
sigmoid_x = step_length/(1+exp(-a*s))
sigmoid_y = step_width/(1+exp(-a*s))

# plot(sigmoid_y)
# show()


# Pref Initialization

t1 = arange(0 , step_time-2*0.1*step_time+time_step , time_step)
t0x = arange(0 , 2*step_time-0.1*step_time+time_step   , time_step)
t0y = arange(0 , step_time-0.1*step_time+time_step   , time_step)

p_ref1x = step_length*ones(( len(t1) ))
p_ref1y = step_width*ones(( len(t1) ))
p_ref0 = zeros(( len(t1)-1 ))
p_ref0_0x = zeros(( len(t0x)-1 ))
p_ref0_0y = (step_width/2)*ones(( len(t0y)-1 ))


out.COMx = 0         
out.COMy = 0
out.COMz = zc -bend_knees       
out.Swing_x = 0       
out.Swing_y = 0
out.Swing_z = bend_knees

# Main Loop

go = 0
Leg = 1
left = 1 # when Leg=1 right leg is swing leg
ka=0
while not rospy.is_shutdown():

  if(ka>6):
   out.COMx =  out.COMx #0.04*sin( 6.28*0.0008*(ka-6) )#out.COMx #  0.02*cos( 6.28*0.0008*(ka-6) )#out.COMx   #
   out.COMy =  out.COMy    #0.04*sin( 6.28*0.0008*(ka-6) )  #
   out.COMz = out.COMz  
   out.Swing_x = out.Swing_x     
   out.Swing_y = out.Swing_y
   out.Swing_z = out.Swing_z  
   out.leg = Leg 
  # rospy.loginfo(out.COMy)
  ka = ka +1
  
  pub_zmp.publish(out) 
  interval.sleep()

  if ns.walk == 1:
      
      rospy.loginfo("started walking")
      rospy.loginfo("time:")
      rospy.loginfo(rospy.get_time())
      D     = 0.0
      x     = array([0.0 , 0.0 , 0.0])[:,newaxis]   
      y     = array([step_width/2 , 0.0 , 0.0])[:,newaxis]                             
      p_x   = 0.0
      p_y   = 0.0
      sum_e_x = 0
      sum_e_y = 0
      k     = 1
      step_length_z = step_length;
      step_time_z = step_time;
      pre_step = 1
      first_step = 0
      full_step = 0
      last_step_mes = 0
      go = 1
      steps_count = -1
      last_step = 0
      step_done = 0
      swing_x_v = []
      swing_z_v = []
      p_ref_x = r_[ p_ref0_0x , sigmoid_x , p_ref1x ]
      p_ref_y = r_[ p_ref0_0y , sigmoid_y/2+step_width/2 , p_ref1y ]
      swing_z_t_more_double_support = 0
      swing_x_t_more_double_support = 0

  while go == 1:

  #######################################################
  #                                                     #
  # sagital control   (x)                               #
  #                                                     #
  #######################################################

      while len(p_ref_x) < k+NL:
 
          D = D + step_length


          a = p_ref_x[0:len(p_ref_x)-1]

          b = sigmoid_x[0:len(sigmoid_x)-1]         
          c = p_ref1x

          d = r_[b,c]+D*ones(( len(r_[b,c]) )) #step_length*ones(2*len(r_[b,c]))#                            for debuging
          p_ref_x = r_[a,d]

      #end while len(p_ref)
 

    
      SumGd = dot(Gd,p_ref_x[k:k+NL])
 
      e = p_x - p_ref_x[k-1]
  
      sum_e_x = sum_e_x + e
  
      u =  - Gi*sum_e_x  - SumGd -dot( Gx , x )

      x = dot(A,x) + (B*u)[:,newaxis]
      
      p_x = dot(C,x) 

  #######################################################
  #                                                     #
  # lateral control  (y)                                #
  #                                                     #
  #######################################################

      while len(p_ref_y) < k+NL:
 
          if left == 1:

              a = p_ref_y[0:len(p_ref_y)-1]
  
              b = sigmoid_y[0:len(sigmoid_y)-1][::-1]      
              c = p_ref0[0:len(p_ref1y)]
              d = r_[b,c]#step_width/2*ones(3*len(p_ref1y))#                              for debuging
   
              p_ref_y = r_[a,d]

              left = 0

          elif left == 0:

              a = p_ref_y[0:len(p_ref_y)-1]

              b = sigmoid_y[0:len(sigmoid_y)-1]         
              c = p_ref1y[0:len(p_ref1y)]
              d = r_[b,c]#step_width/2*ones(3*len(p_ref1y))#                                 for debuging

              p_ref_y = r_[a,d]

              left = 1


      #end while len(p_ref_y)

      SumGd = dot(Gd,p_ref_y[k:k+NL])
 
      e = p_y - p_ref_y[k-1]
  
      sum_e_y = sum_e_y + e
  
      u =  - Gi*sum_e_y  - SumGd -dot( Gx , y )

      y = dot(A,y) + (B*u)[:,newaxis]
      
      p_y = dot(C,y)

  #######################################################
  #                                                     #
  # foot trajectory                                     #
  #                                                     #
  #######################################################

      k_total = step_time*100
      k_start_swing =  round(k_total/3)
      k_stop_swing =   round(2*k_total/3)

      if pre_step:
         swing_pre_step = abs(sin(pi/(step_time_z)*(k-1)*(time_step)))
         swing_x_t = 0 
         swing_y = 0
         swing_z_t = 0 

      if full_step:  
         #swing_x_t = -step_length_z + 2*(k-1)*time_step*step_length_z/step_time_z
         swing_y = 0
         swing_z_t = 0.05*abs(sin(pi/step_time_z*(k-1)*time_step))


         if(k>k_start_swing  and k<k_stop_swing ):
              swing_x_t_more_double_support = -step_length_z +2*(k-k_start_swing)*step_length/(k_stop_swing - k_start_swing)
              swing_z_t_more_double_support = step_height*abs( (sin(pi/(k_stop_swing -k_start_swing)*(k - k_start_swing)))**2 ) #step_height*abs(sin(pi/(k_stop_swing -k_start_swing)*(k - k_start_swing)))  
         elif k<k_start_swing:
              swing_z_t_more_double_support = 0
              swing_x_t_more_double_support = -step_length
         elif k>k_stop_swing:
              swing_z_t_more_double_support = 0
              swing_x_t_more_double_support = step_length



      if first_step:  

         #swing_x_t = (k-1)*time_step*step_length/step_time
         #rospy.loginfo(swing_x_t)
         swing_y = 0#-0.02*(k-1)*time_step/step_time 
         swing_z_t = 0.06*abs(sin(pi/step_time*(k-1)*time_step))
 
         if(k>k_start_swing  and k<k_stop_swing ):
              swing_x_t_more_double_support = (k-k_start_swing)*step_length/(k_stop_swing - k_start_swing)
              swing_z_t_more_double_support = step_height*abs( (sin(pi/(k_stop_swing -k_start_swing)*(k - k_start_swing)))**2 )  
 
         elif k<k_start_swing:
              swing_z_t_more_double_support = 0
              swing_x_t_more_double_support = 0 #-step_length
         elif k>k_stop_swing:
              swing_z_t_more_double_support = 0
              swing_x_t_more_double_support = step_length
      if last_step:  
         swing_x_t = -step_length_z + (k-1)*time_step*step_length_z/step_time_z
         swing_y = 0
         swing_z_t = 0.05*abs(sin(pi/step_time_z*(k-1)*time_step))

      
      swing_x_v = r_[ swing_x_v , swing_x_t_more_double_support ]
      swing_z_v = r_[ swing_z_v , swing_z_t_more_double_support ]
  #######################################################
  #                                                     #
  # publish zmp                                         #
  #                                                     #
  #######################################################

      out.COMx = x[0]
      out.COMy = y[0] - step_width/2
      out.COMz = zc -bend_knees
      out.Swing_x = swing_x_t_more_double_support
      out.Swing_y = swing_y
      out.Swing_z = swing_z_t_more_double_support + bend_knees
      out.leg = Leg                                                           #1           for debuging

      pub_zmp.publish(out) 
  
     # rospy.loginfo('COMy=%f' %out.COMy )
  #######################################################
  #                                                     #
  # command control                                     #
  #                                                     #
  ####################################################### 
      if swing_pre_step < 0.00001 and pre_step and k>1:
         first_step = 1
         pre_step = 0
         rospy.loginfo("done pre step")
         rospy.loginfo("time:")
         rospy.loginfo(rospy.get_time())

         plot(p_ref_x)
         plot(p_ref_y)
         plot(swing_z_v)
         #show()
         p_ref_x = p_ref_x[k:len(p_ref_x)]
         p_ref_y = p_ref_y[k:len(p_ref_y)]
         k = 0
         

      if swing_z_t < 0.00001 and k>1 and not pre_step:
         step_done = 1
         steps_count = steps_count + 1
         rospy.loginfo("done step number: %d" % (steps_count) )
         rospy.loginfo("time:")
         rospy.loginfo(rospy.get_time())
         

         plot(swing_z_v)
        # show()
       

         rospy.loginfo(steps_count)
         p_ref_x = p_ref_x[k:len(p_ref_x)]
         p_ref_y = p_ref_y[k:len(p_ref_y)]    
         k = 0
         if steps_count > 0:
            Leg = int(Leg!=1)
         rospy.loginfo("Right Leg:")
         rospy.loginfo(Leg)
         if steps_count > -1:
            plot(p_ref_x)
            plot(p_ref_y)
            plot(swing_x_v)
            plot(swing_z_v)
           # show()
            #rospy.loginfo("exited")
            #exit()
   

      if first_step and step_done and ns.walk:
         first_step = 0
         full_step = 1
         
      if ns.walk == 0 and step_done and not last_step:
         last_step = 1
         first_step = 0
         full_step = 0
         last_step_mes = p_ref_x[k] 
    
      if p_ref_x[k] >= last_step_mes+step_length and last_step:
         go = 0
         rospy.loginfo("stoped walking")


      #rospy.loginfo(k)
      step_done = 0
      interval.sleep()
      k  = k + 1
      
  #end while go

#end while not rospy.is_shutdown()
