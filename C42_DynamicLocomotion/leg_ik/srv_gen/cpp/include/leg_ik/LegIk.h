/* Auto-generated by genmsg_cpp for file /home/darpa/rosworkspace/leg_ik/srv/LegIk.srv */
#ifndef LEG_IK_SERVICE_LEGIK_H
#define LEG_IK_SERVICE_LEGIK_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "ros/service_traits.h"

#include "leg_ik/traj.h"


#include "leg_ik/LegAngle.h"

namespace leg_ik
{
template <class ContainerAllocator>
struct LegIkRequest_ {
  typedef LegIkRequest_<ContainerAllocator> Type;

  LegIkRequest_()
  : pos()
  {
  }

  LegIkRequest_(const ContainerAllocator& _alloc)
  : pos(_alloc)
  {
  }

  typedef  ::leg_ik::traj_<ContainerAllocator>  _pos_type;
   ::leg_ik::traj_<ContainerAllocator>  pos;


  typedef boost::shared_ptr< ::leg_ik::LegIkRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::leg_ik::LegIkRequest_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct LegIkRequest
typedef  ::leg_ik::LegIkRequest_<std::allocator<void> > LegIkRequest;

typedef boost::shared_ptr< ::leg_ik::LegIkRequest> LegIkRequestPtr;
typedef boost::shared_ptr< ::leg_ik::LegIkRequest const> LegIkRequestConstPtr;


template <class ContainerAllocator>
struct LegIkResponse_ {
  typedef LegIkResponse_<ContainerAllocator> Type;

  LegIkResponse_()
  : ang()
  {
  }

  LegIkResponse_(const ContainerAllocator& _alloc)
  : ang(_alloc)
  {
  }

  typedef  ::leg_ik::LegAngle_<ContainerAllocator>  _ang_type;
   ::leg_ik::LegAngle_<ContainerAllocator>  ang;


  typedef boost::shared_ptr< ::leg_ik::LegIkResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::leg_ik::LegIkResponse_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct LegIkResponse
typedef  ::leg_ik::LegIkResponse_<std::allocator<void> > LegIkResponse;

typedef boost::shared_ptr< ::leg_ik::LegIkResponse> LegIkResponsePtr;
typedef boost::shared_ptr< ::leg_ik::LegIkResponse const> LegIkResponseConstPtr;

struct LegIk
{

typedef LegIkRequest Request;
typedef LegIkResponse Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;
}; // struct LegIk
} // namespace leg_ik

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::leg_ik::LegIkRequest_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::leg_ik::LegIkRequest_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::leg_ik::LegIkRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "e199d522e509fc3ab2b108c764fa0e52";
  }

  static const char* value(const  ::leg_ik::LegIkRequest_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xe199d522e509fc3aULL;
  static const uint64_t static_value2 = 0xb2b108c764fa0e52ULL;
};

template<class ContainerAllocator>
struct DataType< ::leg_ik::LegIkRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "leg_ik/LegIkRequest";
  }

  static const char* value(const  ::leg_ik::LegIkRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::leg_ik::LegIkRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "leg_ik/traj pos\n\
\n\
================================================================================\n\
MSG: leg_ik/traj\n\
float64 COMx\n\
float64 COMy\n\
float64 COMz\n\
float64 Swing_x\n\
float64 Swing_y\n\
float64 Swing_z\n\
int32   leg\n\
\n\
";
  }

  static const char* value(const  ::leg_ik::LegIkRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::leg_ik::LegIkRequest_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros


namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::leg_ik::LegIkResponse_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::leg_ik::LegIkResponse_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::leg_ik::LegIkResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "328a48585f80aa570f8bf4ab43f39a9f";
  }

  static const char* value(const  ::leg_ik::LegIkResponse_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x328a48585f80aa57ULL;
  static const uint64_t static_value2 = 0x0f8bf4ab43f39a9fULL;
};

template<class ContainerAllocator>
struct DataType< ::leg_ik::LegIkResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "leg_ik/LegIkResponse";
  }

  static const char* value(const  ::leg_ik::LegIkResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::leg_ik::LegIkResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "leg_ik/LegAngle ang\n\
\n\
================================================================================\n\
MSG: leg_ik/LegAngle\n\
float64 mhx\n\
float64 lhy\n\
float64 uhz\n\
float64 kny\n\
float64 lax\n\
float64 uay\n\
float64 mby\n\
float64 ubx\n\
\n\
";
  }

  static const char* value(const  ::leg_ik::LegIkResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::leg_ik::LegIkResponse_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::leg_ik::LegIkRequest_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.pos);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct LegIkRequest_
} // namespace serialization
} // namespace ros


namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::leg_ik::LegIkResponse_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.ang);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct LegIkResponse_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace service_traits
{
template<>
struct MD5Sum<leg_ik::LegIk> {
  static const char* value() 
  {
    return "b11527b1e6596cdbc96c7b94f75be9c7";
  }

  static const char* value(const leg_ik::LegIk&) { return value(); } 
};

template<>
struct DataType<leg_ik::LegIk> {
  static const char* value() 
  {
    return "leg_ik/LegIk";
  }

  static const char* value(const leg_ik::LegIk&) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<leg_ik::LegIkRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "b11527b1e6596cdbc96c7b94f75be9c7";
  }

  static const char* value(const leg_ik::LegIkRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<leg_ik::LegIkRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "leg_ik/LegIk";
  }

  static const char* value(const leg_ik::LegIkRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<leg_ik::LegIkResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "b11527b1e6596cdbc96c7b94f75be9c7";
  }

  static const char* value(const leg_ik::LegIkResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<leg_ik::LegIkResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "leg_ik/LegIk";
  }

  static const char* value(const leg_ik::LegIkResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace service_traits
} // namespace ros

#endif // LEG_IK_SERVICE_LEGIK_H

