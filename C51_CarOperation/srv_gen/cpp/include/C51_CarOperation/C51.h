/* Auto-generated by genmsg_cpp for file /home/ariy/robil/C51_CarOperation/srv/C51.srv */
#ifndef C51_CAROPERATION_SERVICE_C51_H
#define C51_CAROPERATION_SERVICE_C51_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "ros/service_traits.h"

#include "C51_CarOperation/C0C51_CL.h"
#include "C51_CarOperation/C0C51_ST.h"
#include "C51_CarOperation/C0C51_PAR.h"
#include "C51_CarOperation/C0C51_TRA.h"


#include "C51_CarOperation/C51C0_NOR.h"
#include "C51_CarOperation/C51C0_OPO.h"

namespace C51_CarOperation
{
template <class ContainerAllocator>
struct C51Request_ {
  typedef C51Request_<ContainerAllocator> Type;

  C51Request_()
  : car_class()
  , start_stop_car()
  , velocity_parameters()
  , travel_parameters()
  {
  }

  C51Request_(const ContainerAllocator& _alloc)
  : car_class(_alloc)
  , start_stop_car(_alloc)
  , velocity_parameters(_alloc)
  , travel_parameters(_alloc)
  {
  }

  typedef  ::C51_CarOperation::C0C51_CL_<ContainerAllocator>  _car_class_type;
   ::C51_CarOperation::C0C51_CL_<ContainerAllocator>  car_class;

  typedef  ::C51_CarOperation::C0C51_ST_<ContainerAllocator>  _start_stop_car_type;
   ::C51_CarOperation::C0C51_ST_<ContainerAllocator>  start_stop_car;

  typedef  ::C51_CarOperation::C0C51_PAR_<ContainerAllocator>  _velocity_parameters_type;
   ::C51_CarOperation::C0C51_PAR_<ContainerAllocator>  velocity_parameters;

  typedef  ::C51_CarOperation::C0C51_TRA_<ContainerAllocator>  _travel_parameters_type;
   ::C51_CarOperation::C0C51_TRA_<ContainerAllocator>  travel_parameters;


  typedef boost::shared_ptr< ::C51_CarOperation::C51Request_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::C51_CarOperation::C51Request_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct C51Request
typedef  ::C51_CarOperation::C51Request_<std::allocator<void> > C51Request;

typedef boost::shared_ptr< ::C51_CarOperation::C51Request> C51RequestPtr;
typedef boost::shared_ptr< ::C51_CarOperation::C51Request const> C51RequestConstPtr;


template <class ContainerAllocator>
struct C51Response_ {
  typedef C51Response_<ContainerAllocator> Type;

  C51Response_()
  : Normal_abnormal_travel()
  , Car_Position()
  {
  }

  C51Response_(const ContainerAllocator& _alloc)
  : Normal_abnormal_travel(_alloc)
  , Car_Position(_alloc)
  {
  }

  typedef  ::C51_CarOperation::C51C0_NOR_<ContainerAllocator>  _Normal_abnormal_travel_type;
   ::C51_CarOperation::C51C0_NOR_<ContainerAllocator>  Normal_abnormal_travel;

  typedef  ::C51_CarOperation::C51C0_OPO_<ContainerAllocator>  _Car_Position_type;
   ::C51_CarOperation::C51C0_OPO_<ContainerAllocator>  Car_Position;


  typedef boost::shared_ptr< ::C51_CarOperation::C51Response_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::C51_CarOperation::C51Response_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct C51Response
typedef  ::C51_CarOperation::C51Response_<std::allocator<void> > C51Response;

typedef boost::shared_ptr< ::C51_CarOperation::C51Response> C51ResponsePtr;
typedef boost::shared_ptr< ::C51_CarOperation::C51Response const> C51ResponseConstPtr;

struct C51
{

typedef C51Request Request;
typedef C51Response Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;
}; // struct C51
} // namespace C51_CarOperation

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::C51_CarOperation::C51Request_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::C51_CarOperation::C51Request_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::C51_CarOperation::C51Request_<ContainerAllocator> > {
  static const char* value() 
  {
    return "8461b9eb687a36bbf117720d381ba9f5";
  }

  static const char* value(const  ::C51_CarOperation::C51Request_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x8461b9eb687a36bbULL;
  static const uint64_t static_value2 = 0xf117720d381ba9f5ULL;
};

template<class ContainerAllocator>
struct DataType< ::C51_CarOperation::C51Request_<ContainerAllocator> > {
  static const char* value() 
  {
    return "C51_CarOperation/C51Request";
  }

  static const char* value(const  ::C51_CarOperation::C51Request_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::C51_CarOperation::C51Request_<ContainerAllocator> > {
  static const char* value() 
  {
    return "C51_CarOperation/C0C51_CL car_class\n\
C51_CarOperation/C0C51_ST start_stop_car\n\
C51_CarOperation/C0C51_PAR velocity_parameters\n\
C51_CarOperation/C0C51_TRA travel_parameters\n\
\n\
================================================================================\n\
MSG: C51_CarOperation/C0C51_CL\n\
float32 car\n\
\n\
================================================================================\n\
MSG: C51_CarOperation/C0C51_ST\n\
int32 car_start_stop\n\
int32 START_CAR=1\n\
int32 STOP_CAR=0\n\
\n\
================================================================================\n\
MSG: C51_CarOperation/C0C51_PAR\n\
float32 PARV_VM\n\
float32 PARV_VT\n\
\n\
================================================================================\n\
MSG: C51_CarOperation/C0C51_TRA\n\
string TRA_RNDF\n\
string TAR_MDF\n\
string TAR_DES\n\
\n\
";
  }

  static const char* value(const  ::C51_CarOperation::C51Request_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros


namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::C51_CarOperation::C51Response_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::C51_CarOperation::C51Response_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::C51_CarOperation::C51Response_<ContainerAllocator> > {
  static const char* value() 
  {
    return "7442f59f7ac3cb421b554533cfdc87e5";
  }

  static const char* value(const  ::C51_CarOperation::C51Response_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x7442f59f7ac3cb42ULL;
  static const uint64_t static_value2 = 0x1b554533cfdc87e5ULL;
};

template<class ContainerAllocator>
struct DataType< ::C51_CarOperation::C51Response_<ContainerAllocator> > {
  static const char* value() 
  {
    return "C51_CarOperation/C51Response";
  }

  static const char* value(const  ::C51_CarOperation::C51Response_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::C51_CarOperation::C51Response_<ContainerAllocator> > {
  static const char* value() 
  {
    return "C51_CarOperation/C51C0_NOR Normal_abnormal_travel\n\
C51_CarOperation/C51C0_OPO Car_Position\n\
\n\
\n\
================================================================================\n\
MSG: C51_CarOperation/C51C0_NOR\n\
int32 normal_abnormal_travel\n\
int32 NORMAL_TRAVEL=0\n\
int32 ABNORMAL_TRAVEL=1\n\
\n\
================================================================================\n\
MSG: C51_CarOperation/C51C0_OPO\n\
int32 x\n\
int32 y\n\
int32 z\n\
\n\
";
  }

  static const char* value(const  ::C51_CarOperation::C51Response_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::C51_CarOperation::C51Response_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::C51_CarOperation::C51Request_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.car_class);
    stream.next(m.start_stop_car);
    stream.next(m.velocity_parameters);
    stream.next(m.travel_parameters);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct C51Request_
} // namespace serialization
} // namespace ros


namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::C51_CarOperation::C51Response_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.Normal_abnormal_travel);
    stream.next(m.Car_Position);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct C51Response_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace service_traits
{
template<>
struct MD5Sum<C51_CarOperation::C51> {
  static const char* value() 
  {
    return "1034508cae6a9c4a3a01b3856e8fe54d";
  }

  static const char* value(const C51_CarOperation::C51&) { return value(); } 
};

template<>
struct DataType<C51_CarOperation::C51> {
  static const char* value() 
  {
    return "C51_CarOperation/C51";
  }

  static const char* value(const C51_CarOperation::C51&) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<C51_CarOperation::C51Request_<ContainerAllocator> > {
  static const char* value() 
  {
    return "1034508cae6a9c4a3a01b3856e8fe54d";
  }

  static const char* value(const C51_CarOperation::C51Request_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<C51_CarOperation::C51Request_<ContainerAllocator> > {
  static const char* value() 
  {
    return "C51_CarOperation/C51";
  }

  static const char* value(const C51_CarOperation::C51Request_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<C51_CarOperation::C51Response_<ContainerAllocator> > {
  static const char* value() 
  {
    return "1034508cae6a9c4a3a01b3856e8fe54d";
  }

  static const char* value(const C51_CarOperation::C51Response_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<C51_CarOperation::C51Response_<ContainerAllocator> > {
  static const char* value() 
  {
    return "C51_CarOperation/C51";
  }

  static const char* value(const C51_CarOperation::C51Response_<ContainerAllocator> &) { return value(); } 
};

} // namespace service_traits
} // namespace ros

#endif // C51_CAROPERATION_SERVICE_C51_H

